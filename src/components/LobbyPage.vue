<template>
  <div class="lobby-page">
    <div style="text-align: center; margin-top: 15px;">
      <span style="font-size: 28px; font-weight: bold">{{ lobbyName }} </span>
      <span class="code" @click="copyToClipboard">{{ lobbyCode }}</span>
      <span v-if="copied" class="copied-message">–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!</span>
    </div>
    <div class="players">
      –ò–≥—Ä–æ–∫–∏:
      <ul style="margin: 10px 0px 0px 0px;">
        <li v-if="owner">
          {{ owner }} üëë
        </li>
        <li v-for="player in sortedPlayers" :key="player.email">
          {{ player.email }} <span class="score">{{ player.score }}</span>
        </li>
      </ul>
    </div>
    <button @click="leaveLobby">–ü–æ–∫–∏–Ω—É—Ç—å –ª–æ–±–±–∏</button>
    <!-- –ö–Ω–æ–ø–∫–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∞—É–¥–∏–æ –æ—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –¥–ª—è –≤–ª–∞–¥–µ–ª—å—Ü–∞ -->
    <div class="audio-controls" v-if="isOwner || respondent == email">
      <button @click="toggleMicrophone" v_if = "isMuted">
        {{ isMuted ? '–í–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω' : '–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω' }}
      </button>
    </div>
  </div>
</template>

<script>
import { io } from 'socket.io-client';

export default {
  props: ['lobbyCode', 'playerName', 'email'],
  data() {
    return {
      lobbyName: '',
      scores: [],
      players: [],
      pollingInterval: null,
      copied: false,
      socket: null,
      localStream: null,
      peers: {},
      isMuted: false, // –¥–ª—è –≤–ª–∞–¥–µ–ª—å—Ü–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –º–∏–∫—Ä–æ—Ñ–æ–Ω –≤–∫–ª—é—á–µ–Ω, –∞ –¥–ª—è –Ω–µ-–≤–ª–∞–¥–µ–ª—å—Ü–µ–≤ –º—ã –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–º—É—á–∏–≤–∞–µ–º
      owner: '',
      respondent: ''
    };
  },
  computed: {
    isOwner() {
      return this.email === this.owner;
    },
    processedPlayers() {
      return this.players.map((email, index) => ({
        email,
        score: this.scores[index] || 0
      }));
    },
    sortedPlayers() {
      // –ò—Å–∫–ª—é—á–∞–µ–º –≤–ª–∞–¥–µ–ª—å—Ü–∞ –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —É–±—ã–≤–∞–Ω–∏—é
      return this.processedPlayers
        .filter(p => p.email !== this.owner)
        .sort((a, b) => b.score - a.score);
    }
  },
  async created() {
    // –°–Ω–∞—á–∞–ª–∞ –ø–æ–ª—É—á–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ª–æ–±–±–∏, —á—Ç–æ–±—ã –∑–Ω–∞—Ç—å, –∫—Ç–æ –≤–ª–∞–¥–µ–ª–µ—Ü
    await this.fetchLobbyInfo();
    // –ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ –∑–∞–ø—É—Å–∫–∞–µ–º WebRTC
    this.setupWebRTC();
    this.setupPolling();
  },
  beforeUnmount() {
    this.stopPolling();
    this.cleanupWebRTC();
  },
  watch: {
    // –ö–∞–∫ —Ç–æ–ª—å–∫–æ –ø–æ–ª—É—á–∏–º –≤–ª–∞–¥–µ–ª—å—Ü–∞, –µ—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤–ª–∞–¥–µ–ª–µ—Ü ‚Äì –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ –º–∏–∫—Ä–æ—Ñ–æ–Ω –≤—ã–∫–ª—é—á–µ–Ω
    owner(newOwner) {
      console.log(newOwner)
      if (!this.isOwner && this.localStream) {
        this.isMuted = true;
        this.localStream.getAudioTracks().forEach(track => {
          track.enabled = false;
        });
      }
    }
  },
  methods: {
    async fetchLobbyInfo() {
      try {
        const response = await fetch('http://localhost:5000/get-lobby-info', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ lobby_code: this.lobbyCode })
        });
        const data = await response.json();
        if (data.status === 'success') {
          console.log(data);
          this.lobbyName = data.lobby_name;
          this.players = data.players;
          this.scores = data.scores;
          this.owner = data.owner;
          this.respondent = data.respondent;
          // –ï—Å–ª–∏ —Å–µ—Ä–≤–µ—Ä –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç question_number –∏ question_nominal,
          // –ø–µ—Ä–µ–¥–∞—ë–º –∏—Ö –≤ —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–∏–π –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è home-page
          this.$emit('update-lobby-info', {
            owner: this.owner,
            respondent: this.respondent,
            question_number: data.question_number,
            question_nominal: data.question_nominal
          });
          // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –º–æ–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä—è—Ç—å, —á—Ç–æ –∏–≥—Ä–æ–∫ –µ—Å—Ç—å –≤ –ª–æ–±–±–∏ –∏ –≤—ã–ø–æ–ª–Ω—è—Ç—å –ø—Ä–æ—á–∏–µ –¥–µ–π—Å—Ç–≤–∏—è
          const isPlayerInLobby = this.players.includes(this.email);
          if (!isPlayerInLobby) {
            console.log('–ò–≥—Ä–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ª–æ–±–±–∏, –≤—ã–ø–æ–ª–Ω—è–µ–º –≤—ã—Ö–æ–¥');
            this.leaveLobby();
          }
        } else {
          this.stopPolling();
          this.$emit('leave-lobby');
        }
      } catch (error) {
        this.leaveLobby();
      }
    },
    
    async leaveLobby() {
      try {
        console.log("–ü–æ–∫–∏–¥–∞–µ–º –ª–æ–±–±–∏...");
        this.cleanupWebRTC();
        const response = await fetch('http://localhost:5000/leave-lobby', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            lobby_code: this.lobbyCode,
            email: this.email,
            player_name: this.playerName
          })
        });
        const data = await response.json();
        console.log("–û—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞:", data);
        if (data.status !== 'success') {
          return;
        }
        this.stopPolling();
        this.$emit('leave-lobby');
      } catch (error) {
        this.stopPolling();
        localStorage.removeItem('lobby');
        this.$emit('leave-lobby');
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–∑ –ª–æ–±–±–∏:", error);
      }
    },
    setupPolling() {
      this.pollingInterval = setInterval(() => {
        this.fetchLobbyInfo();
      }, 1000);
    },
    stopPolling() {
      if (this.pollingInterval) {
        clearInterval(this.pollingInterval);
        this.pollingInterval = null;
      }
    },
    async copyToClipboard() {
      try {
        await navigator.clipboard.writeText(this.lobbyCode);
        this.copied = true;
        setTimeout(() => { this.copied = false; }, 1000);
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–∏:', error);
      }
    },
    async setupWebRTC() {
      try {
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ Socket.IO
        this.socket = io('http://localhost:5000');
        this.socket.emit('join_lobby', { 
          lobby_code: this.lobbyCode,
          user_id: this.email
        });
        // –ü–æ–ª—É—á–µ–Ω–∏–µ –∞—É–¥–∏–æ –ø–æ—Ç–æ–∫–∞
        this.localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –≤–ª–∞–¥–µ–ª–µ—Ü ‚Äì —Å—Ä–∞–∑—É –º—å—é—Ç–∏–º –∞—É–¥–∏–æ
        if (this.owner && !this.isOwner) {
          this.isMuted = true;
          this.localStream.getAudioTracks().forEach(track => {
            track.enabled = false;
          });
        }
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π WebRTC
        this.socket.on('user_joined', this.handleNewUser);
        this.socket.on('webrtc_offer', this.handleOffer);
        this.socket.on('webrtc_answer', this.handleAnswer);
        this.socket.on('ice_candidate', this.handleIceCandidate);
        this.socket.on('user_left', this.handleUserDisconnect);
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ WebRTC:', error);
      }
    },
    handleUserDisconnect({ user_id }) {
      if (this.peers[user_id]) {
        this.peers[user_id].close();
        delete this.peers[user_id];
        console.log(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${user_id} –æ—Ç–∫–ª—é—á–µ–Ω`);
      }
    },
    createPeerConnection(targetId) {
      const peer = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
        ]
      });
      // –î–æ–±–∞–≤–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–µ —Ç—Ä–µ–∫–∏ –ø–µ—Ä–µ–¥ —Å–æ–∑–¥–∞–Ω–∏–µ–º –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è
      this.localStream.getTracks().forEach(track => {
        peer.addTrack(track, this.localStream);
      });
      // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤
      peer.onicecandidate = (event) => {
        if (event.candidate) {
          this.socket.emit('ice_candidate', {
            sender_id: this.email,
            lobby_code: this.lobbyCode,
            target_id: targetId,
            candidate: event.candidate
          });
        }
      };
      // –û–±—Ä–∞–±–æ—Ç–∫–∞ —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞
      peer.ontrack = (event) => {
        const remoteStream = event.streams[0];
        const audioElement = document.createElement('audio');
        audioElement.srcObject = remoteStream;
        audioElement.autoplay = true;
        document.body.appendChild(audioElement);
      };
      return peer;
    },
    async handleNewUser({ user_id }) {
      if (user_id === this.email) return;
      const peer = this.createPeerConnection(user_id);
      this.peers[user_id] = peer;
      const offer = await peer.createOffer();
      await peer.setLocalDescription(offer);
      this.socket.emit('webrtc_offer', {
        sender_id: this.email,
        lobby_code: this.lobbyCode,
        target_id: user_id,
        offer: peer.localDescription
      });
    },
    async handleOffer({ offer, sender_id }) {
      console.log(`–ü–æ–ª—É—á–µ–Ω–æ WebRTC-–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ –æ—Ç ${sender_id}`);
      const peer = this.createPeerConnection(sender_id);
      this.peers[sender_id] = peer;
      await peer.setRemoteDescription(new RTCSessionDescription(offer));
      const answer = await peer.createAnswer();
      await peer.setLocalDescription(answer);
      console.log(`–û—Ç–ø—Ä–∞–≤–∫–∞ WebRTC-–æ—Ç–≤–µ—Ç–∞ ${sender_id}`);
      this.socket.emit('webrtc_answer', {
        sender_id: this.email,
        lobby_code: this.lobbyCode,
        target_id: sender_id,
        answer: peer.localDescription
      });
    },
    async handleAnswer({ answer, sender_id }) {
      console.log(`–ü–æ–ª—É—á–µ–Ω WebRTC-–æ—Ç–≤–µ—Ç –æ—Ç ${sender_id}`);
      const peer = this.peers[sender_id];
      if (!peer) {
        console.error('Peer connection –Ω–µ –Ω–∞–π–¥–µ–Ω');
        return;
      }
      if (peer.signalingState !== 'have-local-offer') {
        console.warn('–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ peer connection:', peer.signalingState);
        return;
      }
      try {
        await peer.setRemoteDescription(new RTCSessionDescription(answer));
      } catch (error) {
        console.error('–û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ –æ–ø–∏—Å–∞–Ω–∏—è:', error);
      }
    },
    async handleIceCandidate({ candidate, sender_id }) {
      const peer = this.peers[sender_id];
      if (!peer || peer.connectionState === 'closed') {
        console.warn('Peer connection –∑–∞–∫—Ä—ã—Ç –∏–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç');
        return;
      }
      try {
        if (candidate) {
          await peer.addIceCandidate(new RTCIceCandidate(candidate));
        }
      } catch (error) {
        console.error(`–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ ICE-–∫–∞–Ω–¥–∏–¥–∞—Ç–∞:`, error);
      }
    },
    toggleMicrophone() {
      this.isMuted = !this.isMuted;
      this.localStream.getAudioTracks().forEach(track => {
        track.enabled = !this.isMuted;
      });
    },
    cleanupWebRTC() {
      Object.entries(this.peers).forEach(([userId, peer]) => {
        peer.close();
        delete this.peers[userId];
      });
      if (this.localStream) {
        this.localStream.getTracks().forEach(track => track.stop());
        this.localStream = null;
      }
      if (this.socket) {
        this.socket.emit('leave_lobby', {
          lobby_code: this.lobbyCode,
          user_id: this.email
        });
        this.socket.disconnect();
        this.socket = null;
      }
    }
  }
};
</script>

<style scoped>
button {
  padding: 10px 20px;
  font-size: 16px;
  margin-top: 20px;
  cursor: pointer;
  background-color: white;
  border-radius: 5px;
  border: 2px solid gray;
  transition-duration: 0.3s;
}
button:hover {
  background-color: #d95252;
  border-radius: 0px;
  border: 2px solid rgba(256,256,256,0);
  color: white;
}
.lobby-page {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}
ul {
  list-style-type: none;
  padding: 0;
}
.code {
  cursor: pointer;
  padding: 2px 5px;
  transition-duration: 0.3s;
  font-size: 25px;
  font-weight: bold;
  color: white;
  background-color: #49824b;
  outline: 2px dashed #49824b;
  outline-offset: -2px;
}
.code:hover {
  background-color: white;
  color: #49824b;
}
.copied-message {
  position: absolute;
  font-size: 15px;
  color: #49824b;
  margin-left: 10px;
  text-align: center;
  background-color: rgba(235,235,235,1);
  padding: 8px;
}
.players {
  width: 100%;
  text-align: left;
  font-size: 20px;
  margin-top: 15px;
}
</style>
